{"ast":null,"code":"var _jsxFileName = \"/Users/pateh1/Desktop/ReactApps/callback-memo-optimization/src/App.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useCallback } from \"react\";\nimport \"./App.css\";\nimport DemoOutput from \"./components/Demo/DemoOutput\";\nimport Button from \"./components/UI/Button/Button\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction App() {\n  _s();\n\n  const [showParagraph, setShowParagraph] = useState(false);\n  const [allowToggle, setAllowToggle] = useState(false);\n  console.log(\"App Running!!!\");\n  const toggleParagraphHandler = useCallback(() => {\n    if (allowToggle) {\n      setShowParagraph(prevShowParagraph => !prevShowParagraph);\n    }\n  }, [allowToggle]);\n\n  const allowToggleHandler = () => {\n    setAllowToggle(true);\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Hi there!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(DemoOutput, {\n      show: showParagraph\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Button, {\n      onClick: allowToggleHandler,\n      children: \" Allow Toggle \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 27,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Button, {\n      onClick: toggleParagraphHandler,\n      children: \" Toggle Paragraph \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 24,\n    columnNumber: 5\n  }, this);\n}\n\n_s(App, \"9l117POqBkkgHsyGOUAkO3R6HtY=\");\n\n_c = App;\nexport default App;\n/*  \n  If we hardcode the show prop as false/true, \n  then DemoOutput wont be re-rendered on the dom as there is no state/prop/context change.\n  But when we click on Toggle Paragraph button, the DemoOutput component will be re-evaluated and re-executed\n  because of App component gets re-evalauted as state got changed. And if DemoOutput has child Components then\n  they will also be re-evaluated unnecessary even if they wont make any change to the dom.\n  So, to optimize this re-evaluation, we need to use React.memo()\n\n  Now, React.memo() will compare the new and the previous props value and check if they are same or not.\n  If same then it wont re-evaluate the function/component.\n\n  But, in javascript method or arrays or objects can't be same. for eg: obj1 = {}, obj2 = {}. obj1 === obj2 => false\n  So, everytime if we reference a method or object or array in props, on re-evaluation it consider as new prop value.\n  Because of this, as we have wrapped Button component in React.memo(), it will get re-evaluated.\n\n  To stop this re-evaluation for references as well, we need to use useCallback hook and wrap our function/reference.\n  useCallback will store that wrapped function in react store and will re-use the same whenever needed. \n\n  There is similar hook to useCallback, that is useMemo which is used to memoise the data or store the data same as useCallback which stores the function\n\n\n  useCallback - stores the function and re-create the function only if dependencies changes\n  useMemo - stores the data and re-create the data only if the dependencies changes\n\n  */\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/Users/pateh1/Desktop/ReactApps/callback-memo-optimization/src/App.js"],"names":["React","useState","useCallback","DemoOutput","Button","App","showParagraph","setShowParagraph","allowToggle","setAllowToggle","console","log","toggleParagraphHandler","prevShowParagraph","allowToggleHandler"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,WAA1B,QAA6C,OAA7C;AAEA,OAAO,WAAP;AACA,OAAOC,UAAP,MAAuB,8BAAvB;AACA,OAAOC,MAAP,MAAmB,+BAAnB;;;AAEA,SAASC,GAAT,GAAe;AAAA;;AACb,QAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoCN,QAAQ,CAAC,KAAD,CAAlD;AACA,QAAM,CAACO,WAAD,EAAcC,cAAd,IAAgCR,QAAQ,CAAC,KAAD,CAA9C;AAEAS,EAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AAEA,QAAMC,sBAAsB,GAAGV,WAAW,CAAC,MAAM;AAC/C,QAAIM,WAAJ,EAAiB;AACfD,MAAAA,gBAAgB,CAAEM,iBAAD,IAAuB,CAACA,iBAAzB,CAAhB;AACD;AACF,GAJyC,EAIvC,CAACL,WAAD,CAJuC,CAA1C;;AAMA,QAAMM,kBAAkB,GAAG,MAAM;AAC/BL,IAAAA,cAAc,CAAC,IAAD,CAAd;AACD,GAFD;;AAIA,sBACE;AAAK,IAAA,SAAS,EAAC,KAAf;AAAA,4BACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADF,eAEE,QAAC,UAAD;AAAY,MAAA,IAAI,EAAEH;AAAlB;AAAA;AAAA;AAAA;AAAA,YAFF,eAGE,QAAC,MAAD;AAAQ,MAAA,OAAO,EAAEQ,kBAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAHF,eAIE,QAAC,MAAD;AAAQ,MAAA,OAAO,EAAEF,sBAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAJF;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAQD;;GAxBQP,G;;KAAAA,G;AA0BT,eAAeA,GAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import React, { useState, useCallback } from \"react\";\n\nimport \"./App.css\";\nimport DemoOutput from \"./components/Demo/DemoOutput\";\nimport Button from \"./components/UI/Button/Button\";\n\nfunction App() {\n  const [showParagraph, setShowParagraph] = useState(false);\n  const [allowToggle, setAllowToggle] = useState(false);\n\n  console.log(\"App Running!!!\");\n\n  const toggleParagraphHandler = useCallback(() => {\n    if (allowToggle) {\n      setShowParagraph((prevShowParagraph) => !prevShowParagraph);\n    }\n  }, [allowToggle]);\n\n  const allowToggleHandler = () => {\n    setAllowToggle(true);\n  }\n\n  return (\n    <div className=\"app\">\n      <h1>Hi there!</h1>\n      <DemoOutput show={showParagraph} />\n      <Button onClick={allowToggleHandler}> Allow Toggle </Button>\n      <Button onClick={toggleParagraphHandler}> Toggle Paragraph </Button>\n    </div>\n  );\n}\n\nexport default App;\n\n/*  \n  If we hardcode the show prop as false/true, \n  then DemoOutput wont be re-rendered on the dom as there is no state/prop/context change.\n  But when we click on Toggle Paragraph button, the DemoOutput component will be re-evaluated and re-executed\n  because of App component gets re-evalauted as state got changed. And if DemoOutput has child Components then\n  they will also be re-evaluated unnecessary even if they wont make any change to the dom.\n  So, to optimize this re-evaluation, we need to use React.memo()\n\n  Now, React.memo() will compare the new and the previous props value and check if they are same or not.\n  If same then it wont re-evaluate the function/component.\n\n  But, in javascript method or arrays or objects can't be same. for eg: obj1 = {}, obj2 = {}. obj1 === obj2 => false\n  So, everytime if we reference a method or object or array in props, on re-evaluation it consider as new prop value.\n  Because of this, as we have wrapped Button component in React.memo(), it will get re-evaluated.\n\n  To stop this re-evaluation for references as well, we need to use useCallback hook and wrap our function/reference.\n  useCallback will store that wrapped function in react store and will re-use the same whenever needed. \n\n  There is similar hook to useCallback, that is useMemo which is used to memoise the data or store the data same as useCallback which stores the function\n\n\n  useCallback - stores the function and re-create the function only if dependencies changes\n  useMemo - stores the data and re-create the data only if the dependencies changes\n\n  */\n"]},"metadata":{},"sourceType":"module"}